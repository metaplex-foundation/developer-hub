---
title: CoreとToken Metadataの違い
metaTitle: CoreとToken Metadataの違い | Core
description: SolanaブロックチェーンにおけるCoreとToken Metadata NFTプロトコルの違い。
---

このページでは、まずTMと比較したCoreの一般的な改善点を探り、後でTM関数の同等のものをCoreでどのように使用できるかについてより技術的な情報を提供します。

## 違いの概要

- **前例のないコスト効率**: Metaplex Coreは利用可能な代替品と比較して最低のミントコストを提供します。例えば、Token Metadataで.022 SOLかかるNFTが、Coreでは.0037 SOLでミントできます。
- **改善された開発者エクスペリエンス**: ほとんどのデジタルアセットが完全なファンジブルトークンプログラムを維持するために必要なデータを継承する一方で、CoreはNFTに最適化されており、すべての重要なデータを単一のSolanaアカウントに保存できます。これにより、開発者の複雑さが大幅に軽減され、Solana全体のネットワークパフォーマンス向上にも貢献します。
- **強化されたコレクション管理**: コレクションのファーストクラスサポートにより、開発者とクリエイターはロイヤリティやプラグインなどのコレクションレベル設定を簡単に管理でき、これらは個別のNFTに対して独自に上書きできます。これは単一のトランザクションで実行でき、コレクション管理コストとSolanaトランザクション手数料を削減します。
- **高度なプラグインサポート**: 組み込みステーキングからアセットベースのポイントシステムまで、Metaplex Coreのプラグインアーキテクチャは広大なユーティリティとカスタマイゼーションの景観を開きます。プラグインにより、開発者は作成、転送、バーンなどのアセットライフサイクルイベントにフックしてカスタム動作を追加できます。
- **互換性とサポート**: Metaplex開発者プラットフォームによって完全にサポートされ、CoreはSDKスイートと今後のプログラムとシームレスに統合され、Metaplexエコシステムを豊かにします。
- **すぐに使えるインデックス化**: Metaplex Digital Asset Standard API（DAS API）を拡張して、Coreアセットは自動的にインデックス化され、すべてのSolana NFTに使用される共通インターフェースを通じてアプリケーション開発者が利用できます。ただし、独特な改善点として、Core attributeプラグインにより、開発者は自動的にインデックス化されるオンチェーンデータを追加できるようになります。

## 技術概要

### 作成

Core Assetを作成するには、単一の作成インストラクションのみが必要です。Token Metadataで必要だったように、後でミントしてメタデータを付加する必要はありません。これにより、複雑さとトランザクションサイズが削減されます。

{% totem %}
{% totem-accordion title="作成" %}
次のスニペットは、アセットデータを既にアップロードしていることを前提としています。

```js
import { generateSigner, percentAmount } from '@metaplex-foundation/umi'
import { create } from '@metaplex-foundation/mpl-core'

const assetAddress = generateSigner(umi)

const result = createV1(umi, {
  asset: assetAddress,
  name: 'My Nft',
  uri: 'https://example.com/my-nft',
}).sendAndConfirm(umi)
```

{% /totem-accordion %}
{% /totem %}

### コレクション

Coreコレクションには複数の新機能が含まれています。コレクションは独自のアカウントタイプであり、通常のアセットとは区別されます。これは、NFTとコレクションの両方を表すために同じアカウントと状態を使用するToken Metadataのアプローチからの歓迎すべき追加であり、両者を区別するのが困難でした。

Coreでは、コレクションは追加機能を可能にする**ファーストクラスアセット**です。例えば、Coreはコレクションにロイヤリティプラグインを追加することで、コレクションレベルのロイヤリティ調整を提供します。開発者とクリエイターは、各アセットを個別に更新することを強制されるのではなく、コレクション内のすべてのアセットを一度に更新できるようになりました。しかし、コレクション内の一部のアセットが異なるロイヤリティ設定を持つべき場合はどうでしょうか？問題ありません - 同じプラグインをアセットに追加するだけで、コレクションレベルのロイヤリティプラグインが上書きされます。

TMでは不可能だったコレクション機能の例として、コレクションレベルロイヤリティがあります - ロイヤリティやクリエイターを変更する際にもう各アセットを更新する必要はなく、コレクションで定義します。これは、コレクションに[ロイヤリティプラグイン](/jp/core/plugins/royalties)を追加することで実現できます。一部のアセットが異なるロイヤリティ設定を持つべきですか？同じプラグインをアセットに追加するだけで、コレクションレベルのロイヤリティプラグインが上書きされます。

フリーズもコレクションレベルで可能です。

コレクションの作成や更新など、コレクションの取り扱いに関する詳細情報は、[コレクション管理](/jp/core/collections)ページで見つけることができます。

### ライフサイクルイベントとプラグイン

アセットのライフサイクル中に、以下のような複数のイベントがトリガーされる可能性があります：

- 作成
- 転送
- 更新
- バーン
- プラグイン追加
- 権限プラグイン承認
- 権限プラグイン削除

TMでは、これらのライフサイクルイベントは所有者または委任者によって実行されます。すべてのTMアセット（nfts/pNfts）には、すべてのライフサイクルイベントに対する関数が含まれています。Coreでは、これらのイベントはアセットまたはコレクション全体レベルで[プラグイン](/jp/core/plugins)によって処理されます。

アセットレベルまたはコレクションレベルの両方に付加されたプラグインは、これらのライフサイクルイベント中に検証プロセスを実行し、イベントの実行を`承認`、`拒否`、または`強制承認`します。

### フリーズ / ロック

TMでアセットをフリーズするには、通常まずフリーズ権限を別のウォレットに委任し、それがNFTをフリーズします。Coreでは、2つのプラグインのいずれかを使用する必要があります：`Freeze Delegate`または`Permanent Freeze Delegate`。後者はアセット作成時にのみ追加できますが、`Freeze Delegate`プラグインは、現在の所有者がトランザクションに署名すれば、いつでも[追加](/jp/core/plugins/adding-plugins)できます。

委任もCoreでより簡単になります。Delegete Recordアカウントを廃止し、委任権限を直接プラグイン自体に保存し、アセット作成時または`addPluginV1`関数を介してアセットにプラグインを追加する際に割り当て可能にしています。

所有者がフリーズ権限を別のアカウントに割り当てる場合、アセットにまだフリーズプラグインがない場合は、その権限でプラグインを追加してフリーズする必要があります。

委任権限に割り当てながら、アセットに`Freeze Delegate`プラグインを追加する簡単な例を以下に示します。

{% totem %}
{% totem-accordion title="フリーズプラグインを追加し、権限を割り当ててフリーズ" %}

```js
await addPlugin(umi, {
  asset: asset.publicKey,
  plugin: createPlugin('FreezeDelegate', { frozen: true }),
  initAuthority: pluginAuthority('Address', { address: delegate.publicKey }),
}).sendAndConfirm(umi)
```

{% /totem-accordion %}
{% /totem %}

さらに、Coreではフリーズは**コレクションレベル**で実行できます。完全なコレクションを単一のトランザクションでフリーズまたは解凍できます。

### アセットステータス

TMでは、アセットの現在のステータスと、それがフリーズ、ロック、または転送可能な状態にあるかどうかを確認するために、複数のアカウントをチェックする必要があることがよくあります。Coreでは、このステータスはアセットアカウントに保存されますが、コレクションアカウントによっても影響を受ける可能性があります。

物事を簡単にするために、`@metaplex-foundation/mpl-core`パッケージに含まれる`canBurn`、`canTransfer`、`canUpdate`などのライフサイクルヘルパーを導入しました。これらのヘルパーは`boolean`値を返し、渡されたアドレスがこれらのライフサイクルイベントを実行する権限を持っているかどうかを知らせます。

```js
const burningAllowed = canBurn(authority, asset, collection)
```

## さらなる読み物

上記で説明した機能は氷山の一角に過ぎません。追加の興味深いトピックには以下が含まれます：

- コレクション管理
- プラグイン概要
- [属性プラグイン](/jp/core/plugins/attribute)を使用したオンチェーンデータの追加