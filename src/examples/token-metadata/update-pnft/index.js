/**
 * Example: update-pnft
 *
 * 
 *
 * This file is auto-generated by scripts/build-examples.js
 * Edit the native .js and .rs files, then run: node scripts/build-examples.js
 */

const kitSections = {
  "imports": "import {\n  getUpdateV1InstructionAsync,\n  TokenStandard,\n} from '@metaplex-foundation/mpl-token-metadata-kit';",
  "setup": "// Assuming rpc, rpcSubscriptions, sendAndConfirm, and authority are set up\n\nconst mintAddress = 'mintAddress...'; // The pNFT mint address",
  "main": "// Update the Programmable NFT metadata\n// Note: pNFTs may have rule sets that restrict updates\nconst updateIx = await getUpdateV1InstructionAsync({\n  mint: mintAddress,\n  authority,\n  payer: authority,\n  // Specify fields to update (creators must be explicitly set, use null to keep existing)\n  data: {\n    name: 'Updated pNFT Name',\n    symbol: 'UPNFT',\n    uri: 'https://example.com/updated-pnft.json',\n    sellerFeeBasisPoints: 550,\n    creators: null, // Keep existing creators\n  },\n});\n\nawait sendAndConfirm([updateIx], [authority]);",
  "output": "console.log('pNFT metadata updated');",
  "full": "// [IMPORTS]\nimport {\n  getUpdateV1InstructionAsync,\n  TokenStandard,\n} from '@metaplex-foundation/mpl-token-metadata-kit';\n// [/IMPORTS]\n\n// [SETUP]\n// Assuming rpc, rpcSubscriptions, sendAndConfirm, and authority are set up\n\nconst mintAddress = 'mintAddress...'; // The pNFT mint address\n// [/SETUP]\n\n// [MAIN]\n// Update the Programmable NFT metadata\n// Note: pNFTs may have rule sets that restrict updates\nconst updateIx = await getUpdateV1InstructionAsync({\n  mint: mintAddress,\n  authority,\n  payer: authority,\n  // Specify fields to update (creators must be explicitly set, use null to keep existing)\n  data: {\n    name: 'Updated pNFT Name',\n    symbol: 'UPNFT',\n    uri: 'https://example.com/updated-pnft.json',\n    sellerFeeBasisPoints: 550,\n    creators: null, // Keep existing creators\n  },\n});\n\nawait sendAndConfirm([updateIx], [authority]);\n// [/MAIN]\n\n// [OUTPUT]\nconsole.log('pNFT metadata updated');\n// [/OUTPUT]\n"
}

const umiSections = {
  "imports": "import { publicKey, none, some } from '@metaplex-foundation/umi';\nimport { updateV1 } from '@metaplex-foundation/mpl-token-metadata';",
  "setup": "// Assuming umi is set up with mplTokenMetadata plugin\n\nconst mintAddress = publicKey('mintAddress...');",
  "main": "// Update the Programmable NFT metadata\n// Note: pNFTs may have rule sets that restrict updates\nawait updateV1(umi, {\n  mint: mintAddress,\n  authority: umi.identity,\n  data: some({\n    name: 'Updated pNFT Name',\n    symbol: '',\n    uri: '',\n    sellerFeeBasisPoints: 0,\n    creators: none(),\n  }),\n}).sendAndConfirm(umi);",
  "output": "console.log('pNFT metadata updated');",
  "full": "// [IMPORTS]\nimport { publicKey, none, some } from '@metaplex-foundation/umi';\nimport { updateV1 } from '@metaplex-foundation/mpl-token-metadata';\n// [/IMPORTS]\n\n// [SETUP]\n// Assuming umi is set up with mplTokenMetadata plugin\n\nconst mintAddress = publicKey('mintAddress...');\n// [/SETUP]\n\n// [MAIN]\n// Update the Programmable NFT metadata\n// Note: pNFTs may have rule sets that restrict updates\nawait updateV1(umi, {\n  mint: mintAddress,\n  authority: umi.identity,\n  data: some({\n    name: 'Updated pNFT Name',\n    symbol: '',\n    uri: '',\n    sellerFeeBasisPoints: 0,\n    creators: none(),\n  }),\n}).sendAndConfirm(umi);\n// [/MAIN]\n\n// [OUTPUT]\nconsole.log('pNFT metadata updated');\n// [/OUTPUT]\n"
}

const anchorSections = {
  "imports": "use anchor_lang::prelude::*;\nuse mpl_token_metadata::{\n    accounts::Metadata,\n    instructions::UpdateAsUpdateAuthorityV2CpiBuilder, types::Data,\n};",
  "setup": "#[derive(Accounts)]\npub struct NftUpdateMpl<'info> {\n    pub mint: AccountInfo<'info>,\n    /// CHECK: Handled by CPI\n    #[account(mut)]\n    pub metadata: AccountInfo<'info>,\n    #[account(mut)]\n    pub update_authority: Signer<'info>,\n    /// CHECK: Handled by CPI\n    pub token_metadata_program: AccountInfo<'info>,\n    // Add additional accounts below if needed\n}",
  "main": "pub fn update_nft_mpl_instruction<'info>(\n    ctx: Context<'_, '_, '_, 'info, NftUpdateMpl<'info>>,\n    new_name: Option<String>,\n    new_uri: Option<String>,\n) -> Result<()> {\n    let mint = ctx.accounts.mint.to_account_info();\n    let metadata = ctx.accounts.metadata.to_account_info();\n    let token_metadata_program = ctx.accounts.token_metadata_program.to_account_info();\n\n    // Get the original metadata values\n    let metadata_account = Metadata::try_from(&metadata)?;\n\n    let original_metadata = Data {\n        name: metadata_account.name,\n        symbol: metadata_account.symbol,\n        uri: metadata_account.uri,\n        seller_fee_basis_points: metadata_account.seller_fee_basis_points,\n        creators: metadata_account.creators,\n    };\n\n    let new_metadata = Data {\n        name: new_name.unwrap_or(original_metadata.name),\n        uri: new_uri.unwrap_or(original_metadata.uri),\n        ..original_metadata // Keep the rest of the metadata the same\n    };\n\n    UpdateAsUpdateAuthorityV2CpiBuilder::new(&token_metadata_program)\n        .mint(&mint)\n        .metadata(&metadata)\n        .authority(&ctx.accounts.update_authority)\n        .data(new_metadata)\n\n        // Add remaining data fields to be adjusted to the CPI if needed\n        // https://docs.rs/mpl-token-metadata/latest/mpl_token_metadata/instructions/struct.UpdateAsUpdateAuthorityV2CpiBuilder.html\n        //\n        // .authorization_rules(authorization_rules)\n        // .authorization_rules_program(authorization_rules_program)\n        // .token_record(token_record)\n        .invoke()?;\n\n    Ok(())\n}",
  "output": "",
  "full": "// [IMPORTS]\nuse anchor_lang::prelude::*;\nuse mpl_token_metadata::{\n    accounts::Metadata,\n    instructions::UpdateAsUpdateAuthorityV2CpiBuilder, types::Data,\n};\n// [/IMPORTS]\n\n// [SETUP]\n#[derive(Accounts)]\npub struct NftUpdateMpl<'info> {\n    pub mint: AccountInfo<'info>,\n    /// CHECK: Handled by CPI\n    #[account(mut)]\n    pub metadata: AccountInfo<'info>,\n    #[account(mut)]\n    pub update_authority: Signer<'info>,\n    /// CHECK: Handled by CPI\n    pub token_metadata_program: AccountInfo<'info>,\n    // Add additional accounts below if needed\n}\n// [/SETUP]\n\n// [MAIN]\npub fn update_nft_mpl_instruction<'info>(\n    ctx: Context<'_, '_, '_, 'info, NftUpdateMpl<'info>>,\n    new_name: Option<String>,\n    new_uri: Option<String>,\n) -> Result<()> {\n    let mint = ctx.accounts.mint.to_account_info();\n    let metadata = ctx.accounts.metadata.to_account_info();\n    let token_metadata_program = ctx.accounts.token_metadata_program.to_account_info();\n\n    // Get the original metadata values\n    let metadata_account = Metadata::try_from(&metadata)?;\n\n    let original_metadata = Data {\n        name: metadata_account.name,\n        symbol: metadata_account.symbol,\n        uri: metadata_account.uri,\n        seller_fee_basis_points: metadata_account.seller_fee_basis_points,\n        creators: metadata_account.creators,\n    };\n\n    let new_metadata = Data {\n        name: new_name.unwrap_or(original_metadata.name),\n        uri: new_uri.unwrap_or(original_metadata.uri),\n        ..original_metadata // Keep the rest of the metadata the same\n    };\n\n    UpdateAsUpdateAuthorityV2CpiBuilder::new(&token_metadata_program)\n        .mint(&mint)\n        .metadata(&metadata)\n        .authority(&ctx.accounts.update_authority)\n        .data(new_metadata)\n\n        // Add remaining data fields to be adjusted to the CPI if needed\n        // https://docs.rs/mpl-token-metadata/latest/mpl_token_metadata/instructions/struct.UpdateAsUpdateAuthorityV2CpiBuilder.html\n        //\n        // .authorization_rules(authorization_rules)\n        // .authorization_rules_program(authorization_rules_program)\n        // .token_record(token_record)\n        .invoke()?;\n\n    Ok(())\n}\n// [/MAIN]\n"
}

export const metadata = {
  title: "update-pnft",
  description: "",
  tags: [],
}

export const examples = {
  kit: {
    framework: 'Kit',
    language: 'javascript',
    code: kitSections.full,
    sections: kitSections,
  },

  umi: {
    framework: 'Umi',
    language: 'javascript',
    code: umiSections.full,
    sections: umiSections,
  },

  anchor: {
    framework: 'Anchor',
    language: 'rust',
    code: anchorSections.full,
    sections: anchorSections,
  },

}
