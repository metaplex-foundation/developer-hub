/**
 * Example: burn-pnft
 *
 * 
 *
 * This file is auto-generated by scripts/build-examples.js
 * Edit the native .js and .rs files, then run: node scripts/build-examples.js
 */

const kitSections = {
  "imports": "import {\n  getBurnV1InstructionAsync,\n  TokenStandard,\n} from '@metaplex-foundation/mpl-token-metadata-kit';",
  "setup": "// Assuming rpc, rpcSubscriptions, sendAndConfirm, and authority are set up\n\nconst mintAddress = 'mintAddress...'; // The pNFT mint address",
  "main": "// Burn the Programmable NFT\n// Note: pNFTs have Token Record accounts that are also cleaned up\nconst burnIx = await getBurnV1InstructionAsync({\n  mint: mintAddress,\n  authority,\n  payer: authority,\n  tokenOwner: authority.address,\n  tokenStandard: TokenStandard.ProgrammableNonFungible,\n});\n\nawait sendAndConfirm({\n  instructions: [burnIx],\n  payer: authority,\n});",
  "output": "console.log('pNFT burned:', mintAddress);",
  "full": "// [IMPORTS]\nimport {\n  getBurnV1InstructionAsync,\n  TokenStandard,\n} from '@metaplex-foundation/mpl-token-metadata-kit';\n// [/IMPORTS]\n\n// [SETUP]\n// Assuming rpc, rpcSubscriptions, sendAndConfirm, and authority are set up\n\nconst mintAddress = 'mintAddress...'; // The pNFT mint address\n// [/SETUP]\n\n// [MAIN]\n// Burn the Programmable NFT\n// Note: pNFTs have Token Record accounts that are also cleaned up\nconst burnIx = await getBurnV1InstructionAsync({\n  mint: mintAddress,\n  authority,\n  payer: authority,\n  tokenOwner: authority.address,\n  tokenStandard: TokenStandard.ProgrammableNonFungible,\n});\n\nawait sendAndConfirm({\n  instructions: [burnIx],\n  payer: authority,\n});\n// [/MAIN]\n\n// [OUTPUT]\nconsole.log('pNFT burned:', mintAddress);\n// [/OUTPUT]\n"
}

const umiSections = {
  "imports": "import { publicKey } from '@metaplex-foundation/umi';\nimport { burnV1, TokenStandard } from '@metaplex-foundation/mpl-token-metadata';",
  "setup": "// Assuming umi is set up with mplTokenMetadata plugin\n\nconst mintAddress = publicKey('mintAddress...');",
  "main": "// Burn the Programmable NFT\n// Note: pNFTs have Token Record accounts that are also cleaned up\nawait burnV1(umi, {\n  mint: mintAddress,\n  authority: umi.identity,\n  tokenOwner: umi.identity.publicKey,\n  tokenStandard: TokenStandard.ProgrammableNonFungible,\n}).sendAndConfirm(umi);",
  "output": "console.log('pNFT burned:', mintAddress);",
  "full": "// [IMPORTS]\nimport { publicKey } from '@metaplex-foundation/umi';\nimport { burnV1, TokenStandard } from '@metaplex-foundation/mpl-token-metadata';\n// [/IMPORTS]\n\n// [SETUP]\n// Assuming umi is set up with mplTokenMetadata plugin\n\nconst mintAddress = publicKey('mintAddress...');\n// [/SETUP]\n\n// [MAIN]\n// Burn the Programmable NFT\n// Note: pNFTs have Token Record accounts that are also cleaned up\nawait burnV1(umi, {\n  mint: mintAddress,\n  authority: umi.identity,\n  tokenOwner: umi.identity.publicKey,\n  tokenStandard: TokenStandard.ProgrammableNonFungible,\n}).sendAndConfirm(umi);\n// [/MAIN]\n\n// [OUTPUT]\nconsole.log('pNFT burned:', mintAddress);\n// [/OUTPUT]\n"
}

const shankSections = {
  "imports": "use mpl_token_metadata::instructions::BurnNftCpiBuilder;",
  "setup": "",
  "main": "BurnNftCpiBuilder::new(metadata_program_id.account_info())\n        .metadata(metadata.account_info())\n        .collection_metadata(Some(collection_metadata.account_info()))\n        .owner(owner.account_info())\n        .mint(mint.account_info())\n        .token_account(token.account_info())\n        .master_edition_account(edition.account_info())\n        .spl_token_program(spl_token.account_info())\n        .invoke()?;",
  "output": "",
  "full": "// [IMPORTS]\nuse mpl_token_metadata::instructions::BurnNftCpiBuilder;\n// [/IMPORTS]\n\n// [MAIN]\nBurnNftCpiBuilder::new(metadata_program_id.account_info())\n        .metadata(metadata.account_info())\n        .collection_metadata(Some(collection_metadata.account_info()))\n        .owner(owner.account_info())\n        .mint(mint.account_info())\n        .token_account(token.account_info())\n        .master_edition_account(edition.account_info())\n        .spl_token_program(spl_token.account_info())\n        .invoke()?;\n// [/MAIN]\n"
}

const anchorSections = {
  "imports": "use anchor_lang::prelude::*;\nuse anchor_spl::token::Mint;\nuse mpl_token_metadata::instructions::BurnV1CpiBuilder;",
  "setup": "#[derive(Accounts)]\npub struct PnftBurnMpl<'info> {\n    #[account(mut)]\n    owner: Signer<'info>,\n    #[account(mut)]\n    mint: Account<'info, Mint>,\n    #[account(mut)]\n    metadata: AccountInfo<'info>,\n    #[account(mut)]\n    token: AccountInfo<'info>,\n    #[account(mut)]\n    master_edition: AccountInfo<'info>,\n    #[account(mut)]\n    token_record: AccountInfo<'info>,\n    collection_metadata: Option<AccountInfo<'info>>,\n    spl_token: AccountInfo<'info>,\n    metadata_program_id: AccountInfo<'info>,\n}",
  "main": "pub fn burn_pnft_mpl_instruction<'info>(\n    ctx: Context<'_, '_, '_, 'info, PnftBurnMpl<'info>>,\n) -> Result<()> {\nlet owner = ctx.accounts.owner.to_account_info();\nlet metadata = ctx.accounts.metadata.to_account_info();\nlet mint = ctx.accounts.mint.to_account_info();\nlet token = ctx.accounts.token.to_account_info();\nlet master_edition = ctx.accounts.master_edition.to_account_info();\nlet collection_metadata = ctx\n    .accounts\n    .collection_metadata\n    .as_ref()\n    .map(|a| a.to_account_info());\nlet spl_token = ctx.accounts.spl_token.to_account_info();\nlet token_record = ctx.accounts.token_record.to_account_info();\nlet metadata_program_id = ctx.accounts.metadata_program_id.to_account_info();\n\nBurnV1CpiBuilder::new(&metadata_program_id)\n    .metadata(&metadata)\n    .collection_metadata(collection_metadata.as_ref())\n    .authority(&owner)\n    .mint(&mint)\n    .token(&token)\n    .spl_token_program(&spl_token)\n    .token_record(Some(&token_record))\n    .master_edition(Some(&master_edition))\n    .invoke()?;\n\nOk(())\n}",
  "output": "",
  "full": "// [IMPORTS]\nuse anchor_lang::prelude::*;\nuse anchor_spl::token::Mint;\nuse mpl_token_metadata::instructions::BurnV1CpiBuilder;\n// [/IMPORTS]\n\n// [SETUP]\n#[derive(Accounts)]\npub struct PnftBurnMpl<'info> {\n    #[account(mut)]\n    owner: Signer<'info>,\n    #[account(mut)]\n    mint: Account<'info, Mint>,\n    #[account(mut)]\n    metadata: AccountInfo<'info>,\n    #[account(mut)]\n    token: AccountInfo<'info>,\n    #[account(mut)]\n    master_edition: AccountInfo<'info>,\n    #[account(mut)]\n    token_record: AccountInfo<'info>,\n    collection_metadata: Option<AccountInfo<'info>>,\n    spl_token: AccountInfo<'info>,\n    metadata_program_id: AccountInfo<'info>,\n}\n// [/SETUP]\n\n// [MAIN]\npub fn burn_pnft_mpl_instruction<'info>(\n    ctx: Context<'_, '_, '_, 'info, PnftBurnMpl<'info>>,\n) -> Result<()> {\nlet owner = ctx.accounts.owner.to_account_info();\nlet metadata = ctx.accounts.metadata.to_account_info();\nlet mint = ctx.accounts.mint.to_account_info();\nlet token = ctx.accounts.token.to_account_info();\nlet master_edition = ctx.accounts.master_edition.to_account_info();\nlet collection_metadata = ctx\n    .accounts\n    .collection_metadata\n    .as_ref()\n    .map(|a| a.to_account_info());\nlet spl_token = ctx.accounts.spl_token.to_account_info();\nlet token_record = ctx.accounts.token_record.to_account_info();\nlet metadata_program_id = ctx.accounts.metadata_program_id.to_account_info();\n\nBurnV1CpiBuilder::new(&metadata_program_id)\n    .metadata(&metadata)\n    .collection_metadata(collection_metadata.as_ref())\n    .authority(&owner)\n    .mint(&mint)\n    .token(&token)\n    .spl_token_program(&spl_token)\n    .token_record(Some(&token_record))\n    .master_edition(Some(&master_edition))\n    .invoke()?;\n\nOk(())\n}\n// [/MAIN]\n"
}

export const metadata = {
  title: "burn-pnft",
  description: "",
  tags: [],
}

export const examples = {
  kit: {
    framework: 'Kit',
    language: 'javascript',
    code: kitSections.full,
    sections: kitSections,
  },

  umi: {
    framework: 'Umi',
    language: 'javascript',
    code: umiSections.full,
    sections: umiSections,
  },

  shank: {
    framework: 'Shank',
    language: 'rust',
    code: shankSections.full,
    sections: shankSections,
  },

  anchor: {
    framework: 'Anchor',
    language: 'rust',
    code: anchorSections.full,
    sections: anchorSections,
  },

}
