/**
 * Example: Burn an NFT
 *
 * Burn an NFT using the Token Metadata program
 *
 * This file is auto-generated by scripts/build-examples.js
 * Edit the native .js and .rs files, then run: node scripts/build-examples.js
 */

const kitSections = {
  "imports": "import {\n  getBurnV1InstructionAsync,\n  TokenStandard,\n} from '@metaplex-foundation/mpl-token-metadata-kit';",
  "setup": "// Assuming rpc, rpcSubscriptions, sendAndConfirm, and authority are set up\n// See getting-started for full setup\n\nconst mintAddress = 'mintAddress...'; // The NFT mint address",
  "main": "// Burn the NFT (removes all accounts and closes token account)\nconst burnIx = await getBurnV1InstructionAsync({\n  mint: mintAddress,\n  authority,\n  payer: authority,\n  tokenOwner: authority.address,\n  tokenStandard: TokenStandard.NonFungible,\n});\n\nawait sendAndConfirm({\n  instructions: [burnIx],\n  payer: authority,\n});",
  "output": "console.log('NFT burned:', mintAddress);",
  "full": "// [IMPORTS]\nimport {\n  getBurnV1InstructionAsync,\n  TokenStandard,\n} from '@metaplex-foundation/mpl-token-metadata-kit';\n// [/IMPORTS]\n\n// [SETUP]\n// Assuming rpc, rpcSubscriptions, sendAndConfirm, and authority are set up\n// See getting-started for full setup\n\nconst mintAddress = 'mintAddress...'; // The NFT mint address\n// [/SETUP]\n\n// [MAIN]\n// Burn the NFT (removes all accounts and closes token account)\nconst burnIx = await getBurnV1InstructionAsync({\n  mint: mintAddress,\n  authority,\n  payer: authority,\n  tokenOwner: authority.address,\n  tokenStandard: TokenStandard.NonFungible,\n});\n\nawait sendAndConfirm({\n  instructions: [burnIx],\n  payer: authority,\n});\n// [/MAIN]\n\n// [OUTPUT]\nconsole.log('NFT burned:', mintAddress);\n// [/OUTPUT]\n"
}

const umiSections = {
  "imports": "import { publicKey } from '@metaplex-foundation/umi';\nimport { burnV1, TokenStandard } from '@metaplex-foundation/mpl-token-metadata';",
  "setup": "// Assuming umi is set up with mplTokenMetadata plugin\n// See getting-started for full setup\n\nconst mintAddress = publicKey('mintAddress...');",
  "main": "// Burn the NFT (removes all accounts and closes token account)\nawait burnV1(umi, {\n  mint: mintAddress,\n  authority: umi.identity,\n  tokenOwner: umi.identity.publicKey,\n  tokenStandard: TokenStandard.NonFungible,\n}).sendAndConfirm(umi);",
  "output": "console.log('NFT burned:', mintAddress);",
  "full": "// [IMPORTS]\nimport { publicKey } from '@metaplex-foundation/umi';\nimport { burnV1, TokenStandard } from '@metaplex-foundation/mpl-token-metadata';\n// [/IMPORTS]\n\n// [SETUP]\n// Assuming umi is set up with mplTokenMetadata plugin\n// See getting-started for full setup\n\nconst mintAddress = publicKey('mintAddress...');\n// [/SETUP]\n\n// [MAIN]\n// Burn the NFT (removes all accounts and closes token account)\nawait burnV1(umi, {\n  mint: mintAddress,\n  authority: umi.identity,\n  tokenOwner: umi.identity.publicKey,\n  tokenStandard: TokenStandard.NonFungible,\n}).sendAndConfirm(umi);\n// [/MAIN]\n\n// [OUTPUT]\nconsole.log('NFT burned:', mintAddress);\n// [/OUTPUT]\n"
}

const shankSections = {
  "imports": "use mpl_token_metadata::instructions::BurnNftCpiBuilder;",
  "setup": "",
  "main": "BurnNftCpiBuilder::new(&metadata_program_id)\n    .metadata(&metadata)\n    // if your NFT is part of a collection you will need to pass in the collection metadata address.\n    .collection_metadata(collection_metadata.as_ref())\n    .owner(&owner)\n    .mint(&mint)\n    .token_account(&token)\n    .master_edition_account(&edition)\n    .spl_token_program(&spl_token)\n    .invoke()?;",
  "output": "",
  "full": "// [IMPORTS]\nuse mpl_token_metadata::instructions::BurnNftCpiBuilder;\n// [/IMPORTS]\n\n// [MAIN]\n BurnNftCpiBuilder::new(&metadata_program_id)\n    .metadata(&metadata)\n    // if your NFT is part of a collection you will need to pass in the collection metadata address.\n    .collection_metadata(collection_metadata.as_ref())\n    .owner(&owner)\n    .mint(&mint)\n    .token_account(&token)\n    .master_edition_account(&edition)\n    .spl_token_program(&spl_token)\n    .invoke()?;\n// [/MAIN]\n"
}

const anchorSections = {
  "imports": "use anchor_lang::prelude::*;\nuse anchor_spl::token::Mint;\nuse mpl_token_metadata::instructions::BurnNftCpiBuilder;",
  "setup": "#[derive(Accounts)]\npub struct NftBurnMpl<'info> {\n    #[account(mut)]\n    owner: Signer<'info>,\n    #[account(mut)]\n    mint: Account<'info, Mint>,\n    #[account(mut)]\n    metadata: AccountInfo<'info>,\n    #[account(mut)]\n    token: AccountInfo<'info>,\n    #[account(mut)]\n    edition: AccountInfo<'info>,\n    collection_metadata: Option<AccountInfo<'info>>,\n    spl_token: AccountInfo<'info>,\n    metadata_program_id: AccountInfo<'info>,\n}",
  "main": "pub fn burn_nft_mpl_instruction<'info>(\n    ctx: Context<'_, '_, '_, 'info, NftBurnMpl<'info>>,\n) -> Result<()> {\n    let owner = ctx.accounts.owner.to_account_info();\n    let metadata = ctx.accounts.metadata.to_account_info();\n    let collection_metadata = ctx.accounts.collection_metadata.as_ref().map(|a| a.to_account_info());\n    let mint = ctx.accounts.mint.to_account_info();\n    let token = ctx.accounts.token.to_account_info();\n    let edition = ctx.accounts.edition.to_account_info();\n    let spl_token = ctx.accounts.spl_token.to_account_info();\n    let metadata_program_id = ctx.accounts.metadata_program_id.to_account_info();\n\n    BurnNftCpiBuilder::new(&metadata_program_id)\n        .metadata(&metadata)\n        // if your NFT is part of a collection you will also need to pass in the collection metadata address.\n        .collection_metadata(collection_metadata.as_ref())\n        .owner(&owner)\n        .mint(&mint)\n        .token_account(&token)\n        .master_edition_account(&edition)\n        .spl_token_program(&spl_token)\n        .invoke()?;\n\n    Ok(())\n}",
  "output": "",
  "full": "// [IMPORTS]\nuse anchor_lang::prelude::*;\nuse anchor_spl::token::Mint;\nuse mpl_token_metadata::instructions::BurnNftCpiBuilder;\n// [/IMPORTS]\n\n// [SETUP]\n#[derive(Accounts)]\npub struct NftBurnMpl<'info> {\n    #[account(mut)]\n    owner: Signer<'info>,\n    #[account(mut)]\n    mint: Account<'info, Mint>,\n    #[account(mut)]\n    metadata: AccountInfo<'info>,\n    #[account(mut)]\n    token: AccountInfo<'info>,\n    #[account(mut)]\n    edition: AccountInfo<'info>,\n    collection_metadata: Option<AccountInfo<'info>>,\n    spl_token: AccountInfo<'info>,\n    metadata_program_id: AccountInfo<'info>,\n}\n// [/SETUP]\n\n// [MAIN]\npub fn burn_nft_mpl_instruction<'info>(\n    ctx: Context<'_, '_, '_, 'info, NftBurnMpl<'info>>,\n) -> Result<()> {\n    let owner = ctx.accounts.owner.to_account_info();\n    let metadata = ctx.accounts.metadata.to_account_info();\n    let collection_metadata = ctx.accounts.collection_metadata.as_ref().map(|a| a.to_account_info());\n    let mint = ctx.accounts.mint.to_account_info();\n    let token = ctx.accounts.token.to_account_info();\n    let edition = ctx.accounts.edition.to_account_info();\n    let spl_token = ctx.accounts.spl_token.to_account_info();\n    let metadata_program_id = ctx.accounts.metadata_program_id.to_account_info();\n\n    BurnNftCpiBuilder::new(&metadata_program_id)\n        .metadata(&metadata)\n        // if your NFT is part of a collection you will also need to pass in the collection metadata address.\n        .collection_metadata(collection_metadata.as_ref())\n        .owner(&owner)\n        .mint(&mint)\n        .token_account(&token)\n        .master_edition_account(&edition)\n        .spl_token_program(&spl_token)\n        .invoke()?;\n\n    Ok(())\n}\n// [/MAIN]\n"
}

export const metadata = {
  title: "Burn an NFT",
  description: "Burn an NFT using the Token Metadata program",
  tags: ['token-metadata', 'nft', 'burn', 'beginner'],
}

export const examples = {
  kit: {
    framework: 'Kit',
    language: 'javascript',
    code: kitSections.full,
    sections: kitSections,
  },

  umi: {
    framework: 'Umi',
    language: 'javascript',
    code: umiSections.full,
    sections: umiSections,
  },

  shank: {
    framework: 'Shank',
    language: 'rust',
    code: shankSections.full,
    sections: shankSections,
  },

  anchor: {
    framework: 'Anchor',
    language: 'rust',
    code: anchorSections.full,
    sections: anchorSections,
  },

}
